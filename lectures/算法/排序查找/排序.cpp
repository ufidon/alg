#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cmath>

using namespace std;

typedef int 号型;
typedef int 键型;
typedef vector<键型> 列型;

class 排序
{
public:
    列型 数;

public:
    排序(const 列型 &数) : 数(数)
    {
    }

    // 课本页289算法7.1
    /* 插排法：
    默认升序
    列含左侧已排及右侧未排两部分
    将未排元素插入已排部分
    */
    static void 插排(int 列长, 键型 数[])
    {
        号型 待插号, 插位;
        键型 待插元;

        for (待插号 = 1; 待插号 <= 列长 - 1; 待插号++)
        {
            待插元 = 数[待插号];
            插位 = 待插号 - 1;
            while (插位 >= 0 && 数[插位] > 待插元)
            {
                数[插位 + 1] = 数[插位]; // 右移大于待插元的数
                插位--;
            }
            数[插位 + 1] = 待插元;
        }
    }

    static void 插排(列型 &数)
    {
        int 列长 = 数.size();
        号型 待插号, 插位;
        键型 待插元;

        for (待插号 = 1; 待插号 <= 列长 - 1; 待插号++)
        {
            待插元 = 数[待插号];
            插位 = 待插号 - 1;
            while (插位 >= 0 && 数[插位] > 待插元)
            {
                数[插位 + 1] = 数[插位]; // 右移大于待插元的数
                插位--;
            }
            数[插位 + 1] = 待插元;
        }
    }

    // 课本页8算法1.3
    /* 换排法:
    默认升序
    左侧排好右侧待排
    每次把待排部分左元与其余更小元换位
    遍历其余元后待排最小元被换至待排部分左首
    每次比较若有更小则交换
    */
    static void 换排(int 列长, 键型 数[])
    {
        号型 前, 后;
        for (前 = 0; 前 <= 列长 - 1; 前++)
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[前])
                {
                    //交换 数[后], 数[前]
                    swap(数[后], 数[前]);
                }
            }
    }

    static void 换排(列型 &数)
    {
        int 列长 = 数.size();
        号型 前, 后;
        for (前 = 0; 前 <= 列长 - 1; 前++)
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[前]) // 边比边换
                {
                    //交换 数[后], 数[前]
                    swap(数[后], 数[前]);
                }
            }
    }

    // 课本页292算法7.2
    /* 选排法:
    默认升序
    左侧排好右侧待排
    每次把待排部分左元与其余最小元换位
    */
    static void 选排(列型 &数)
    {
        int 列长 = 数.size();
        号型 前, 后, 丅;
        for (前 = 0; 前 <= 列长 - 1; 前++)
        {
            丅 = 前;
            for (后 = 前 + 1; 后 <= 列长 - 1; 后++)
            {
                if (数[后] < 数[丅]) // 比完再换
                {
                    丅 = 后;
                }
            }
            swap(数[丅], 数[前]);
        }
    }

    // 课本页58算法2.2
    /* 分并法:
    默认升序
    先分后并,边并边排
    */

    static void 并排(const 列型 &甲, const 列型 &乙, 列型 &并)
    {
        号型 j = 0, y = 0, b = 0;
        int 甲长 = 甲.size(), 乙长 = 乙.size();
        while (j < 甲长 && y < 乙长)
        {
            if (甲[j] < 乙[y])
            {
                并[b] = 甲[j];
                j++;
            }
            else
            {
                并[b] = 乙[y];
                y++;
            }
            b++;
        }
        if (j >= 甲长) // 甲先并完, 乙有剩
            copy_n(乙.begin() + y, 乙长 - y, 并.begin() + b);
        else // 乙先并完, 甲有剩
            copy_n(甲.begin() + j, 甲长 - j, 并.begin() + b);
    }

    static void 分并(列型 &数)
    {
        int 列长 = 数.size();
        if (列长 > 1)
        { // 先分
            号型 中点 = 列长 / 2;
            列型 左列, 右列;
            copy(数.begin(), 数.begin() + 中点, back_inserter(左列));
            copy(数.begin() + 中点, 数.end(), back_inserter(右列));
            分并(左列);
            分并(右列);
            // 后并
            并排(左列, 右列, 数);
        }
    }

    // 课本62页2.4算法
    /* 分并排序算法 2

    */
    static void 并排2(列型 &数, 列型 &内, 号型 左号, 号型 中点, 号型 右号)
    {
        号型 左步, 右步, 并步;

        左步 = 左号;
        右步 = 中点 + 1;
        并步 = 左号;
        while (左步 <= 中点 && 右步 <= 右号)
        {
            if (数[左步] < 数[右步])
            {
                内[并步] = 数[左步];
                左步++;
            }
            else
            {
                内[并步] = 数[右步];
                右步++;
            }
            并步++;
        }
        if (左步 > 中点) // 左侧先并完,右侧有余
        {
            copy_n(数.begin() + 右步, 右号 - 右步 + 1, 内.begin() + 并步);
        }
        else
        { // 右侧先并完, 左侧有余
            copy_n(数.begin() + 左步, 中点 - 左步 + 1, 内.begin() + 并步);
        }
        cout << "左号" << 左号 << "中点" << 中点 << "右号" << 右号 << endl;
        cout << "数:" << 印列(数) << "内:" << 印列(内) << endl;
        copy_n(内.begin() + 左号, 右号 - 左号 + 1, 数.begin() + 左号);
    }

    static void 分合(列型 &数, 列型 &内, 号型 左号, 号型 右号)
    {
        号型 中点;
        if (左号 < 右号)
        {
            // 先分
            中点 = (左号 + 右号) / 2;
            分合(数, 内, 左号, 中点);
            分合(数, 内, 中点 + 1, 右号);
            // 后并
            并排2(数, 内, 左号, 中点, 右号);
        }
    }

    static void 分并2(列型 &数)
    {
        号型 左号 = 0, 右号 = 数.size() - 1;
        列型 内(数.size(), 0);
        分合(数, 内, 左号, 右号);
    }

    static void 分并3(列型 &数)
    {
        int 列长 = 数.size();
        int 遍数 = (int)ceil(log2(列长));
        int 幂2列长 = 2 << 遍数;
        号型 左号, 中号, 右号;
        键型 内(列长);
        bool 数至内 = true;

        int 层长 = 1;
        while (遍数--)
        {
            /* code */
        }
    }

    // 课本65页算法2.6
    /* 快排
    先分后排
    划界: 界左数小于界, 界右数大于等于界
    */
    static void 划(列型 &数, 号型 左号, 号型 右号, 号型 &界号)
    {
        号型 步, 界步;
        键型 界数 = 数[左号]; // 取左数为界数
        界步 = 左号;

        for (步 = 左号 + 1; 步 <= 右号; 步++)
        {
            if (数[步] < 界数)
            {
                界步++;
                swap(数[界步], 数[步]);
                cout << "寻(" << 界数 << ")" << 印列(数) << endl;
            }
        }
        界号 = 界步; // 定界于最后交换位
        swap(数[左号], 数[界号]);
        cout << "定(" << 界数 << ")" << 印列(数) << endl;
        cout << "划(" << 界数 << ")" << 印列(数, 左号, 界号 - 1) << "|" << 数[界号] << "|" << 印列(数, 界号 + 1, 右号) << endl;
    }

    static void 速排(列型 &数, 号型 左号, 号型 右号)
    {
        号型 界号;
        if (右号 > 左号)
        {
            划(数, 左号, 右号, 界号);
            速排(数, 左号, 界号 - 1);
            速排(数, 界号 + 1, 右号);
        }
    }

    static void 快排(列型 &数)
    {
        号型 左号 = 0, 右号 = 数.size() - 1;
        速排(数, 左号, 右号);
    }

    // 印列

    static string 印列(int 列长, 键型 数[])
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }

    static string 印列(const 列型 &数)
    {
        int 列长 = 数.size();
        stringstream ss;
        ss << "[";
        for (号型 号 = 0; 号 <= 列长 - 1; 号++)
        {
            ss << 数[号] << (号 == 列长 - 1 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
    static string 印列(const 列型 &数, const 号型 起, const 号型 止)
    {
        stringstream ss;
        ss << "[";
        for (号型 号 = 起; 号 <= 止; 号++)
        {
            ss << 数[号] << (号 == 止 ? "" : ",");
        }
        ss << "]";
        return ss.str();
    }
};
int main()
{
    列型 数 = {3, 9, 8, 4, 3, 7, 2, 0, 1};

    排序 排1(数);
    cout << "插入排序:" << endl;
    cout << "排序前:" << 排序::印列(排1.数) << endl;
    排序::插排(排1.数);
    cout << "排序后:" << 排序::印列(排1.数) << endl;

    排序 排2(数);
    cout << "\n换位排序:" << endl;
    cout << "排序前:" << 排序::印列(排2.数) << endl;
    排序::换排(排2.数);
    cout << "排序后:" << 排序::印列(排2.数) << endl;

    排序 排3(数);
    cout << "\n换丅排序:" << endl;
    cout << "排序前:" << 排序::印列(排3.数) << endl;
    排序::选排(排3.数);
    cout << "排序后:" << 排序::印列(排3.数) << endl;

    排序 排4(数);
    cout << "\n分并排序:" << endl;
    cout << "排序前:" << 排序::印列(排4.数) << endl;
    排序::分并(排4.数);
    cout << "排序后:" << 排序::印列(排4.数) << endl;

    排序 排5(数);
    cout << "\n分并2排序:" << endl;
    cout << "排序前:" << 排序::印列(排5.数) << endl;
    排序::分并2(排5.数);
    cout << "排序后:" << 排序::印列(排5.数) << endl;

    排序 排6(数);
    cout << "\n快速排序:" << endl;
    cout << "排序前:" << 排序::印列(排6.数) << endl;
    排序::快排(排6.数);
    cout << "排序后:" << 排序::印列(排6.数) << endl;
}